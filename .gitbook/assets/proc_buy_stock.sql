SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		chen 
-- Create date: 2021.3.18
-- Description:	Ri巡
-- =============================================
/*
DECLARE @ERRMSG	VARCHAR(1000)
EXEC PROC_BUY_STOCK '2021/1/15',2330,'585H1234567',1500,@ERRMSG OUTPUT
PRINT @ERRMSG
SELECT * FROM STOCK_DEAL
*/
create or alter PROCEDURE PROC_BUY_STOCK--ユN把计
@DATE date,--ユ訾榇
@SYMBOL	varchar(10),--巡讥N腹
@TDCCACCOUNT	varchar(20),--栋Ob腹
@QTY	decimal(20,4),--Riq
@ERRMSG	varchar(1000) output--岿~T
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	IF NOT EXISTS(SELECT * FROM STOCK_NAME_FULL WHERE SYMBOL=@SYMBOL)
	BEGIN
		SELECT @ERRMSG='巡讥N腹ぃsb'
		RETURN;
	END;

	--o程j歉
	DECLARE @MAXNO	VARCHAR(20)
	DECLARE @SERIAL VARCHAR(20)
	SELECT @MAXNO=ISNULL(MAX(SERIAL),'190001010000') FROM STOCK_DEAL
	SELECT @MAXNO=CONVERT(VARCHAR(20),CONVERT(INT,RIGHT(@MAXNO,4))+1)
	SELECT @MAXNO=RIGHT('0000'+@MAXNO,4)
	SELECT @SERIAL=CONVERT(VARCHAR(10),@DATE,112)+@MAXNO
	--o巡级}L基
	DECLARE @PRICE DECIMAL(20,4)
	SELECT @PRICE=[OPEN]
	FROM STOCK_PRICE
	WHERE DATE=@DATE AND SYMBOL=@SYMBOL
	DECLARE @myfee DECIMAL(20,4)
	Select @myfee= CASE WHEN ROUND(@PRICE*@QTY*0.01,0)<=100000 THEN ROUND(@PRICE*@QTY*0.01,0) ELSE ROUND(@PRICE*@QTY*0.005,0) END 
	--n干
	IF NOT EXISTS(SELECT * FROM STOCK_PRICE WHERE  DATE=@DATE and SYMBOL=@SYMBOL    )
	BEGIN
		SELECT @ERRMSG='L基姘T'
		RETURN;
	END;

	BEGIN TRAN
	BEGIN TRY
	
		INSERT STOCK_DEAL --insertDEAL
		(
		SERIAL,DATE,SYMBOL,TDCCACCOUNT,DATATYPE,
		QTY,PRICE,AMT,FEE,TAX,
		TOTALAMT,
		LOGDATE
		)

		SELECT @SERIAL AS SERIAL,@DATE AS [DATE],@SYMBOL AS SYMBOL,@TDCCACCOUNT AS TDCCACCOUNT,1 AS DATATYPE,
		@QTY AS QTY,@PRICE AS PRICE,ROUND(@PRICE*@QTY,0) AS AMT,
		@myfee AS FEE, -- o娩P_O_WL10U
		ROUND(@PRICE*@QTY*0.003,0) AS TAX,
		ROUND(@PRICE*@QTY,0)+
		@myfee+
		ROUND(@PRICE*@QTY*0.003,0) AS TOTALAMT,
		GETDATE() AS LOGDATE


		COMMIT
	END TRY
	BEGIN CATCH
		ROLLBACK
		SELECT @ERRMSG=ERROR_MESSAGE()
	END CATCH
END
GO
